{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MicroBlocks + ESP32 STEAMakers + TdRSTRAM","text":"<p>Gu\u00eda de actividades b\u00e1sicas creadas a partir del trio de elementos del t\u00edtulo:</p> <ul> <li>MicroBlocks. Introduciremos su uso.</li> <li>ESP32 STEAMakers + TdRSTRAM. Nos basaremos tanto en Mis notas sobre ESP32 STEAMakers de @fgcoca.</li> </ul> <p>Nos vamos a basar en la Libreria creada por la TechWoman, Kathy Giori de microbloks.fun disponible como TdR STEAM dentro del directorio de Kits y placas.</p> <p> <p> Libreria TdR STEAM en MicroBlocks</p> <p></p> <p>Se desarrollar\u00e1n activades para todos los elementos que componen la TdR STEAM, enlazando todas al fichero con el proyecto resuelto. Tambi\u00e9n se propondr\u00e1n actividades que en la mayor parte de los casos no van a estar resueltas, sino propuestas.</p>"},{"location":"mblocks/","title":"Microblocks","text":"<p>MicroBlocks es una herramienta de programaci\u00f3n por bloques basada en Snap!. Se trata de un software que puede trabajar online o localmente y que nos va a permitir programar diferentes placas, entre ellas la micro:bit.</p> <p> <p> Logotipo de MicroBlocks</p> <p>Logotipo descargado de la entrada en SAP de Kathy Giori  titulada Recap of \u201cSneak Preview into MicroBlocks\u201d.</p> <p></p> <p>MicroBlocks es un lenguaje de programaci\u00f3n por bloques similar a Scratch que es una excelente herramienta para aprender desde nivel principiante hasta nivel experto y v\u00e1lido para edades que van desde los 8 hasta los 99 a\u00f1os.</p> <p>En el apartado Get Started de su web tenemos descrito como trabajar desde un navegador y los distintos sistemas operativos as\u00ed como los pasos a seguir para configurar nuestra placa y como comenzar a crear programas.</p> <p>En esta ocasi\u00f3n vamos a trabajar de forma local descargando e instalando el programa en nuestro ordenador. En mi caso trabajar\u00e9 con Linux de 64 bits instalando el paquete debian descargado 'ublocks-amd64.deb'. La forma elegida para instalarlo, suponiendo que el paquete est\u00e1 en Descargas, es:</p> <pre><code>sudo dpkg -i ~/Descargas/ublocks-amd64.deb\n</code></pre> <p>Tras la instalaci\u00f3n verificamos que todo est\u00e1 correcto y que Linux ve la placa ejecutando en una terminal lo que vemos en la imagen siguiente.</p> <p> <p> Verificaci\u00f3n de conexi\u00f3n con micro:bit en Linux</p> <p></p> <p>En el enlace Mis notas sobre Linux trabajando con Ubuntu tenemos un par de entradas que describen problemas con el paquete brltty (Braille TTY). En el caso de placas con un chip microcontrolador de la serie USB CP210x, algunas de ellas compatibles con MicroBlocks. Si tenemos este caso el problema se puede resolver eliminando el paquete BRLTTY.</p> <pre><code>sudo apt remove brltty\n</code></pre> <p>El programa una vez instalado lo tenemos disponible en aplicaciones, como vemos en la imagen siguiente.</p> <p> <p> App MicroBlocks disponible</p> <p></p>"},{"location":"mblocks/#por-que-usar-microblocks","title":"\u00bfPor qu\u00e9 usar MicroBlocks?","text":"<p>MicroBlocks tiene una caracter\u00edstica que lo distingue de otros lenguajes de programaci\u00f3n por bloques y es que la programaci\u00f3n real ocurre seg\u00fan se desarrolla el programa, lo que podemos denominar como programaci\u00f3n en directo o en vivo y, debido a esto, que implica que el c\u00f3digo se descarga seg\u00fan se escribe tenemos la otra caracter\u00edstica que le dota de independencia o autonom\u00eda, ya que cuando demos el programa por bueno, este ya est\u00e1 grabado como firmware en la placa.</p> <p>Otra de la caracter\u00edsticas importantes que ofrece MicroBlocks es la multitarea o posibilidad de desarrollar funcionalidades que trabajan de forma paralela y separada cada tarea. Por ejemplo, reproducir un sonido mientras se controla un servomotor. Esta forma de trabajo hace que el c\u00f3digo sea mas sencillo de escribir y de entender.</p> <p>Cuando trabajamos con MicroBlocks la placa que conectemos se comporta como una tarjeta de memoria. No hay necesidad de leer un archivo de proyecto, simplemente conectamos la placa y el script o programa nos aparecer\u00e1 en el IDE. Es decir, MicroBlocks lee el programa que hay en la placa y lo carga de manera autom\u00e1tica.</p> <p>El funcionamiento de MicroBlocks se basa en:</p> <ul> <li>El editor de bloques o IDE que se puede ejecutar online o de manera local.</li> <li>Una m\u00e1quina virtual que se ejecuta en la placa microcontroladora. Esta m\u00e1quina virtual es la encargada de ejecutar el programa de usuario y lo hace compilando en c\u00f3digo de bytes o instrucciones de bajo nivel muy parecidas al c\u00f3digo m\u00e1quina. Si tenemos habilitados los bloques avanzados podemos ver los bytes generados por el programa, como vemos en la animaci\u00f3n siguiente:</li> </ul> <p> <p> C\u00f3digo de bytes</p> <p></p> <p>La parte m\u00e1s importante de la informaci\u00f3n de bytes es la primera l\u00ednea, que muestra el n\u00famero de bytes compilados. Los scripts en MicroBlocks no deben superar los 1000 bytes, de ah\u00ed la importancia de esta informaci\u00f3n.</p> <ul> <li>El sistema de comunicaci\u00f3n entre la placa y el host remoto o el ordenador que hace que el firmware se actualice seg\u00fan se escribe el programa. Este sistema es el encargado de enviar los bytes y comandos para iniciar el programa y procesar mensajes del microcontrolador. As\u00ed el editor proporciona realimentaci\u00f3n gr\u00e1fica de lo que sucede en el microcontrolador y directamente puede mostrar valolres en un \"bocadillo de conversaci\u00f3n\" como el de la figura siguiente.</li> </ul> <p> <p> Bocadillo de conversaci\u00f3n</p> <p></p> <p>MicroBlocks tambi\u00e9n dispone de una herramienta de representaci\u00f3n gr\u00e1fica que estudiaremos en su momento.</p> <p>Una funcionalidad importante del editor es que, adem\u00e1s de programar por bloques, administra las Librerias, que est\u00e1n escritas en MicroBlocks. Existen muchas que iremos viendo poco a poco. Las librerias escritas en MicroBlocks pueden ser editadas por los usuarios.</p>"},{"location":"mblocks/#los-cuatro-pilares-de-microblocks","title":"Los cuatro pilares de MicroBlocks","text":"<p>Seg\u00fan Bernat Romagosa, que forma parte del equipo de MicroBlocks, este es un software en vivo capaz de trabajar con varias placas diferentes como micro:bit, nodemcu y otras muchas. El lenguaje est\u00e1 desarrollado en torno a cuatro conceptos que consideran esenciales para un lenguaje de programaci\u00f3n educativo. Ellos los llaman los cuatro pilares de MicroBlocks:</p> <ol> <li>Vivo. El primero de estos pilares es que MicroBlocks es un lenguaje de programaci\u00f3n \"en directo\" o \"en vivo\", lo que significa que puedo arrastrar un bloque a la zona de programa y ver el resultado de cambiarlo en la ejecuci\u00f3n en la placa de manera inmediata. Esto significa que no hay que esperar ni ciclos de carga ni compilaciones ni nada de esto. El programa trabaja en tiempo real con la placa.</li> <li>Multitarea. El segundo pilar es que se trata de un lenguaje de programaci\u00f3n multitares o que trabaja en paralelo, lo que significa que se pueden ejecutar varias tareas al mismo tiempo.</li> <li>Aut\u00f3nomo. El tercero de los pilares es que MicroBlocks es un lenguaje aut\u00f3nomo, lo que significa que si, en cualquier momento, desconectamos la micro:bit del ordenador y alimentamos de forma externa el programa se seguir\u00e1 ejecutando tal y como estaba sin modificaciones y sin tener que presionar ning\u00fan bot\u00f3n. No hay que esperar ning\u00fan ciclo de carga de firmware.</li> <li>Portatil. El cuarto pilar es que se trata de un programa dise\u00f1ado para que sea portatil por lo que si cambiamos de tipo de placa, esta seguir\u00e1 ejecutando exactamente el mismo programa. La portabilidad se ha llevado al extremos de que si nos hemos olvidado de guardar nuestro programa en el ordenador, simplemente con conectar la placa este se carga en el IDE o tambi\u00e9n podemos, con la placa desconectada, escoger la opci\u00f3n de \"Recuperar proyecto de la placa\" que est\u00e1 en el men\u00fa del icono \"Fichero\". Tengase en cuenta que en este proceso los comentarios se pierden.</li> </ol> <p>Un sencillo ejemplo nos servir\u00e1 para ver todo esto. Se trata de crear un programa en el que un coraz\u00f3n lata en la pantalla a un intervalo determinado por una variable. Con el bot\u00f3n A disminuiremos el intervalo y con el bot\u00f3n B lo aumentaremos. El programa se debe ir creando en orden, con una placa conectada y eject\u00e1ndose la tarea principal, para poder ir viendo los cambios que hagamos como se reflejan en la placa inmediatamente. El programa es:</p> <p> <p> Ejemplo cuatro pilares</p> <p>Basado en Exploring sound with the micro:bit V2 &amp; MicroBlocks, MicroBlocks Team</p> <p></p> <p>Descargar el programa</p>"},{"location":"mblocks/#configuracion-del-equipo","title":"Configuraci\u00f3n del equipo","text":"<p>Necesitamos un ordenador (\u00a1no un dispositivo m\u00f3vil!) con un puerto USB, un cable USB y una placa soportada. Podemos ejecutar MicroBlocks en un navegador Chromium, Chrome o Edge, o descargarlo como una aplicaci\u00f3n independiente para Linux, Chromebook, Windows o MacOS. Las placas soportadas son:</p> <ul> <li>BBC micro:bit v1 y v2</li> <li>Calliope mini</li> <li>Circuit Playground Express y Bluefruit</li> <li>Citilab ED1</li> <li>Raspberry Pi Pico and Pico W</li> <li>Adafruit Clue</li> <li>M5Stack Core Grey</li> <li>ESP8266 y ESP32</li> </ul> <p>Los instaladores est\u00e1n disponibles para las versiones liberadas listas para descargar la apropiada para nuestro sistema operativo. Si estamos trabajando con Chrome o Edge es muy posible que nos advierta de que estamos descargando un archivo que podr\u00eda da\u00f1ar nuestro ordenador. Debemos ignorar esta y sucesivas advertencias para proceder con la descarga.</p> <p>En Linux se descarga un paquete .deb, ublocks-amd64.deb en concreto para esta ocasi\u00f3n que se instala de forma muy sencilla. Con una terminal abierta en el directorio donde est\u00e1 el archivo .deb tecleamos:</p> <pre><code>dpkg -i ~/Descargas/ublocks-amd64.deb\n</code></pre> <p>Tras breves instantes el programa estar\u00e1 instalado y lo tendremos disponible en aplicaciones, como ya hemos visto antes.</p>"},{"location":"mblocks/#configuracion-de-la-placa","title":"Configuraci\u00f3n de la placa","text":"<p>El proceso de configuraci\u00f3n de las placas soportadas es muy similar en todas ellas y es seguir el proceso que vamos a ver a continuaci\u00f3n. En este caso particular se toman las im\u00e1genes y animaciones realizando el proceso con una micro:bit V2.21.</p> <p>Conectamos la placa al ordenador y en el men\u00fa de MicroBlocks hacemos clic en el engranaje y seleccionamos la opci\u00f3n 'actualizar firmware de la placa'.</p> <p> <p> Actualizar firmware de la placa</p> <p></p> <p>En el men\u00fa de la ventana emergente tenemos que seleccionar el tipo de placa que hemos conectado.</p> <p> <p> Seleccionar placa</p> <p></p> <p>Si estamos trabajando con MicroBlocks en un navegador, se nos pedir\u00e1 que seleccionemos la placa si a\u00fan no est\u00e1 conectada.</p> <p>Si no hay una placa conectada aparecer\u00e1 el siguiente aviso.</p> <p> <p> No puedo abrir puerto serie</p> <p></p> <p>Si todo est\u00e1 correcto el icono del puerto USB pasa a estar acompa\u00f1ado de un c\u00edrculo verde que indica la conexi\u00f3n.</p> <p> <p> Conexi\u00f3n por puerto serie realizada</p> <p></p> <p>En este video del canal Youtube de MicroBlocks Fun titulado Quick introduction to MicroBlocks for programming a micro:bit (Introducci\u00f3n r\u00e1pida a MicroBlocks para programar un micro:bit) tenemos una introducci\u00f3n r\u00e1pida a MicroBlocks con micro:bit.</p> <p>La informaci\u00f3n en ingl\u00e9s de la guia de usuario y el manual de referencia de bloques tambi\u00e9n pueden resultarnos de gran ayuda.</p>"},{"location":"mblocks/#actualizar-firmware-en-esp32","title":"Actualizar firmware en ESP32","text":"<p>Los dispositivos ESP son una categor\u00eda especial de Espressif que cuentan con capacidad WIFI. En estas placas se borra totalmente el contenido de la memoria flash de la placa y se carga el firmware m\u00e1s reciente. Tras seleccionar ESP32 se inicia la actualizaci\u00f3n del firmware y aparece informaci\u00f3n del progreso en la pantalla.</p> <p> <p> Actualizar firmware en ESP32</p> <p></p>"},{"location":"mblocks/#habilitardeshabilitar-autocarga-de-librerias","title":"Habilitar/deshabilitar autocarga de librerias","text":"<p>Una de las cosas buenas del editor MicroBlocks es que siempre trata de simplificar las cosas a los usuarios. Dado que cada placa con microcontrolador tiene diferentes caracter\u00edsticas, funciones y capacidades, MicroBlocks intenta de forma autom\u00e1tica complementar las funcionalidades b\u00e1sicas cargando las bibliotecas que estime necesarias, siempre que la opci\u00f3n est\u00e9 habilitada, que se distinguir\u00e1 porque la opci\u00f3n disponible es desactivar.</p> <p> <p> Autocarga de librerias activada</p> <p></p> <p>Cuando se selecciona, este elemento se deshabilita esta funcionalidad y depende del usuario cargar las bibliotecas requeridas.</p> <p> <p> Autocarga de librerias desactivada</p> <p></p>"},{"location":"mblocks/#habilitardeshabilitar-plugshare","title":"Habilitar/deshabilitar PlugShare","text":"<p>Otra caracter\u00edstica muy interesante del editor de MicroBlocks es que cargar\u00e1 autom\u00e1ticamente un proyecto desde el microcontrolador conecvtado, si no hay otro proyecto cargado en el editor. La activaci\u00f3n y desactivaci\u00f3n de la opci\u00f3n es id\u00e9ntica a la de la carga de librer\u00edas. Si la opci\u00f3n muestra desactivar es que est\u00e1 habilitada por lo que el editor leer\u00e1 el proyecto desde el dispositivo y luego proceder\u00e1 a cargarlo en el editor. Si la opci\u00f3n muestra activar es que la funcionalidad no est\u00e1 habilitada.</p> <p>Esta funci\u00f3n es muy importante porque permite a los usuarios compartir proyectos simplemente intercambiando sus dispositivos f\u00edsicos y conect\u00e1ndolos a un ordenador. No hay que compartir archivos.</p> <p>Podr\u00edamos denominar a esta funcionalidad como \"conecta y comparte\".</p> <p> <p> PlugShare activado</p> <p></p>"},{"location":"mblocks/#descripcion-general","title":"Descripci\u00f3n general","text":"<p>En la imagen siguiente vemos los nombres de las distintas partes que componen el editor de MicroBlocks.</p> <p> <p> Partes del editor</p> <p></p> <ul> <li>Bloques. Los bloques est\u00e1n organizados por categorias codificadas por colores. Cuando se selecciona una categor\u00eda se despliegan los correspondientes a esa categoria en la zona denominada paleta de bloques. En la wiki de MicroBlocks podemos encontrar una referencia completa a los bloques (Block Reference) con multitud de ejemplos resueltos.</li> <li>Barra de men\u00fas. Contiene, de izquierda a derecha, el icono en forma de globo terraqueo para configurar el idioma, la rueda dentada para entrar en opciones de MicroBlocks, la hoja de papel que muestra el men\u00fa archivo, el gr\u00e1fico es un men\u00fa con opciones de graficar y conectar y el conector USB para el men\u00fa conectar.</li> <li>Nombre del proyecto. Es el nombre del proyecto actual.</li> <li>Botones de inicio/parada. Son dos iconos que sirven para controlar la ejecuci\u00f3n de los programas.</li> <li>Librerias. Aqu\u00ed se muestran las diversas bibliotecas que se cargan seg\u00fan sea requerido.</li> <li>\u00c1rea de bloques de programa. Es donde se crea el programa o script de usuario y las funciones, que en MicroBlocks se conocen como bloques personalizados.</li> <li>Barra de informaci\u00f3n. Si vamos moviendo el rat\u00f3n por los diversos bloques y \u00e1reas del IDE en esta barra se muestra el tipo de bloque y una breve informaci\u00f3n de ayuda sobre los bloques; as\u00ed como la funcionalidad de las distintas \u00e1reas. La informaci\u00f3n detallada del bloque est\u00e1 disponible a trav\u00e9s del men\u00fa contextual de cada bloque.</li> <li>Controles tama\u00f1o bloques. Estos tres controles permiten cambiar el tama\u00f1o de los bloques aumentando (+) o disminuyendo (-), as\u00ed como establecerlos en el tama\u00f1o predeterminado o del 100% de zoom (=).</li> </ul>"},{"location":"mblocks/#idioma","title":"Idioma","text":"<p>En la imagen siguiente vemos el men\u00fa desplegado.</p> <p> <p> Idioma</p> <p></p> <p>Simplemente tenemos que seleccionar el idioma deseado de entre los que est\u00e1 traducido MicroBlocks. Esto configura todos los men\u00fas, mensajes y bloques de c\u00f3digo en ese idioma. La operaci\u00f3n puede demorarse unos segundos dependiendo del equipo en el que se est\u00e9 ejecutando el programa.</p>"},{"location":"mblocks/#microblocks_1","title":"MicroBlocks","text":"<p>En la figura siguiente vemos este men\u00fa desplegado.</p> <p> <p> MicroBlocks</p> <p></p> <ul> <li>La opci\u00f3n 'acerca de...' nos muestra la informaci\u00f3n sobre MicroBlocks que vemos en la imagen siguiente.</li> </ul> <p> <p> acerca de...</p> <p></p> <ul> <li>Actualizar el firmware de la placa es lo que permite al usuario cargar la \u00faltima versi\u00f3n del firmware en la placa conectada. Dependiendo de los dispositivos conectados y de las condiciones se puede desplegar un men\u00fa para seleccionar el dispositivo concreto. Es la opci\u00f3n que utilizaremos para grabar los programas en la placa.</li> <li>Mostrar bloques avanzados modifica el men\u00fa MicroBlocks mostrando mas opciones, como vemos en la imagen siguiente.</li> </ul> <p> <p> Bloques avanzados</p> <p></p> <ul> <li>La opci\u00f3n versi\u00f3n de firmware nos devuelve la versi\u00f3n de firmware de la m\u00e1quina virtual para micro:bit, como vemos en la imagen siguiente.</li> </ul> <p> <p> versi\u00f3n de firmware</p> <p></p> <ul> <li>La opci\u00f3n borra y reparticiona el firmware en placa ESP borra totalmente el contenido de la memoria y carga el programa actual en placas con capacidad EiFi tipo ESP.</li> <li>La opci\u00f3n inicia el servidor HTTP. Activa (o desactiva si est\u00e1 activo) el servidor HTTP de MicroBlocks en el puerto por defecto 6473, aunque este puede ser cambiado.</li> <li>La opci\u00f3n desactiva autocarga de librerias de placa permite desabilitar la funcionalidad de MicroBlocks de que intente autom\u00e1ticamente complementar las funcionalidades b\u00e1sicas del dispositivo conectado cargando varias bibliotecas.</li> <li>La opci\u00f3n activar PlugShare en proyecto en blanco es una funci\u00f3n que si est\u00e1 habilitada hace que el editor de MicroBlocks cargue autom\u00e1ticamente un proyecto desde el microdispositivo conectado, siempre que no haya un proyecto cargado en el editor. Si el \u00edcono de conexi\u00f3n no es verde y est\u00e1 habilitado PlugShare cuando estamos en un proyecto vac\u00edo, tan pronto como se establezca la conexi\u00f3n USB, MicroBlocks leer\u00e1 y cargar\u00e1 el proyecto que contiene el dispositivo conectado.</li> <li>La opci\u00f3n oculta los bloques avanzados devuelve al men\u00fa MicroBlocks a su estado por defecto, que es la opci\u00f3n mas habitual.</li> </ul>"},{"location":"mblocks/#archivo","title":"Archivo","text":"<p>En la figura siguiente vemos este men\u00fa desplegado.</p> <p> <p> Archivo</p> <p></p> <ul> <li>Guarda. Cuando demos por finalizado un proyecto, o tengamos que dejarlo para otro momento sin perder el trabajo realizado, debemos guardarlo en el ordenador. Se nos abrir\u00e1 una ventana como la de la imagen siguiente.</li> </ul> <p> <p> Guarda fichero</p> <p></p> <ul> <li>Nuevo. Para crear nuevos proyectos. Si tenemos un programa cargado en el \u00e1rea de trabajo del editor, mostrar\u00e1 un mensaje solicitando confirmaci\u00f3n para eliminar del editor el proyecto activo. En la imagen siguiente vemos el mensaje.</li> </ul> <p> <p> Confirmacion</p> <p></p> <p>Si la contestaci\u00f3n es 'Si' el \u00e1rea de trabajo queda vac\u00eda y las bibliotecas a\u00f1adidas por el usuario se borran.</p> <ul> <li>Abre. Esta opci\u00f3n permite cargar en el editor proyectos .ubp previamente guardados. Si hay un proyecto cargado en el \u00e1rea de trabajo, se mostrar\u00e1 un mensaje de confirmaci\u00f3n (igual que en Nuevo) y se presenta una ventana de di\u00e1logo que permite localizar y abrir el archivo deseado. En la imagen siguiente vemos esta ventana.</li> </ul> <p> <p> Di\u00e1logo abrir fichero</p> <p></p> <p>En la categor\u00eda Ejemplos es donde se presentan muchos proyectos de MicroBlocks para diferentes microdispositivos y opciones de hardware.</p> <ul> <li>Copia URL del proyecto al portapapeles. Cuando trabajamos online permite compartir el proyecto.</li> </ul>"},{"location":"mblocks/#conectar","title":"Conectar","text":"<p>En la figura siguiente vemos este men\u00fa desplegado. En esta ocasi\u00f3n hay un dispositivo ya conectado y por eso se muestra la opci\u00f3n disconnect (/dev/ttyACM0).</p> <p> <p> Conectar</p> <p></p> <p>Si tenemos varios dispositivos conectados a puertos USB se nos mostrar\u00e1n los mismos para que podamos escoger el dispositivo que nos interesa. Al seleccionar uno y hacer clic en Conectar se establecer\u00e1 una conexi\u00f3n con el dispositivo correspondiente. Si la conexi\u00f3n tiene \u00e9xito, el \u00edcono USB cambiar\u00e1 a uno con un fondo circular verde, como vemos en la imagen siguiente.</p> <p> <p> Conectado</p> <p></p> <p>Es importante prestar atenci\u00f3n al estado de este icono. MicroBlocks ejecuta muchos procesos internos automatizados y la actualizaci\u00f3n y sincronizaci\u00f3n autom\u00e1tica del c\u00f3digo del proyecto en el dispositivo conectado es uno de ellos, pero esto solo es posible cuando el \u00edcono est\u00e1 en modo verde.</p> <p>Existen diversas razones por las que la conexi\u00f3n puede interrumpirse. Cuando esto ocurre el icono dejar\u00e1 de estar verde y debemos buscar el motivo de la desconexi\u00f3n.</p>"},{"location":"mblocks/#botones-de-inicioparada","title":"Botones de inicio/parada","text":"<p>MicroBlocks siempre est\u00e1 en conexi\u00f3n; se puede hacer clic en bloques o secuencias de comandos individuales para ejecutarlos sin hacer clic en el bot\u00f3n de 'Inicio'.</p> <p>La funci\u00f3n principal del bot\u00f3n 'Inicio' es simular el encendido del dispositivo iniciando todas las secuencias de comandos.</p> <p>El bot\u00f3n 'STOP' detiene la ejecuci\u00f3n del proyecto. Todas las variables son desasignadas. Todos los scripts se detienen.</p> <p>El proyecto cargado en el dispositivo estar\u00e1 en el mismo hasta nueva grabaci\u00f3n de firmware. De hecho, podemos desconectarlo, encenderlo desde una fuente externa y ejecutar el proyecto sin el editor.</p>"},{"location":"mblocks/#programando","title":"Programando","text":"<p>Dado que es la parte en la que mas se trabaja, la creaci\u00f3n de programas, la vemos en su propio apartado.</p> <p>Los bloques colocados en el \u00e1rea de trabajo los podemos mover a voluntad con el rat\u00f3n, as\u00ed como con los men\u00fas contextuales que aparecen al pulsar el bot\u00f3n derecho. Existen una serie de atajos asociados a las teclas Ctrl y Shift que se ir\u00e1n viendo.</p>"},{"location":"mblocks/#arrastrar-y-soltar","title":"Arrastrar y soltar","text":"<p>El movimiento de arrastrar y soltar es el habitual de entornos de programaci\u00f3n por bloques y adem\u00e1s resulta muy intuitivo. Lo nuevo en Microblocks es que mientras se arrastra aparece una sombra paralela que pretende crear un efecto 3D de que el bloque en movimiento va flotando sobre el \u00e1rea de trabajo, incluso por encima del resto de bloques.</p> <p> <p> Sombra paralela</p> <p></p>"},{"location":"mblocks/#acoplar-bloques","title":"Acoplar bloques","text":"<p>Cuando nos acercamos con un bloque o un conjunto de bloques a otro u otros bloques, aparecer\u00e1 una l\u00ednea blanca blanca horizontal que designa un punto de acople.</p> <p> <p> L\u00ednea blanca mostrando punto de acople</p> <p></p> <p>Si soltamos el bot\u00f3n del rat\u00f3n cuando se ve esa l\u00ednea blanca el bloque o bloques se acoplar\u00e1n a los del otro lado de la l\u00ednea.</p>"},{"location":"mblocks/#menu-contextual-de-bloques","title":"Men\u00fa contextual de bloques","text":"<p>Si situamos el cursor sobre un bloque que est\u00e1 en un grupo de bloques y hacemos clic con el bot\u00f3n secundario o derecho, nos aparece un men\u00fa contextual.</p> <p> <p> Men\u00fa contextual en bloques</p> <p></p> <p>Este men\u00fa contextual ofrece mas opciones si hemos seleccionado 'Mostrar bloques avanzados'.</p> <p> <p> Men\u00fa contextual en bloques avanzados</p> <p></p> <ul> <li>Copiar en el portapapeles. Es una operaci\u00f3n que crea una copia de los conjuntos de bloques seleccionados en el portapapeles. Estos se pueden pegar dentro del mismo proyecto o en un proyecto diferente. Tambi\u00e9n es posible copiar/pegar entre el editor online y el local.</li> <li>Copiar al Portapapeles como URL. Esta caracter\u00edstica se utiliza principalmente para incorporar programas MicroBlocks en p\u00e1ginas web, ya que el formato est\u00e1 codificado como URL.</li> </ul>"},{"location":"mblocks/#menu-contextual-de-area-de-trabajo","title":"Men\u00fa contextual de \u00e1rea de trabajo","text":"<p>Es el men\u00fa contextual que aparece cuando hacemos un clic derecho sobre cualquier zona vac\u00eda del \u00e1rea de trabajo.</p> <p> <p> Men\u00fa contextual en \u00e1rea de trabajo</p> <p></p> <ul> <li>tama\u00f1o de bloques. Cuando se selecciona nos muestra una lista con porcentajes para escoger est\u00e1ndo tildado el valor actual.</li> <li>deshaz el \u00faltimo movimiento. Invierte el \u00faltimo movimiento de bloque completado.</li> <li>limpia. Organiza los conjuntos y los bloques sueltos en la pantalla en una disposici\u00f3n de arriba hacia abajo y de izquierda a derecha desde el lado izquierdo del \u00e1rea de trabajo. Los bloques se organizan en m\u00faltiples columnas determinadas por el ancho del \u00e1rea IDE. \u00a1Esta operaci\u00f3n no se puede deshacer!</li> <li>copia todos los programas al portapapeles. Es la pareja de copiar al portapapeles. Mientras que el primero solamente copia el bloque o el programa, este copia todos los programas del proyecto.</li> <li>copia todos los programas al portapapeles como URL. Es lo mismo que el visto anteriormente.</li> <li>guarda una imagen de todos los programas visibles. Es la versi\u00f3n complementaria de la vista en el men\u00fa contextual de bloques.</li> <li>fija la escala de la imagen a exportar. Al seleccionarla nos muestra una lista con porcentajes para escoger est\u00e1ndo tildado el valor actual.</li> </ul>"},{"location":"mblocks/#crear-un-programa","title":"Crear un programa","text":"<p>Por defecto, al iniciar Microblocks aunque se haga con la micro:bit conectada, no tendremos disponibles los bloques de manejo de la pantalla de 5x5 LEDs. Estos bloques se encuentran en la libreria 'Pantalla LED' que debemos a\u00f1adir a nuestro programa. Desde 'Control debemos situar los bloques 'al empezar' y 'por siempre'.</p> <p>Repetimos el 'Primer proyecto' en el que vamos a utilizar, adem\u00e1s de los dos nombrados, el 'limpia pantalla' y 'muestra car\u00e1cter'. En la animaci\u00f3n siguiente vemos el proceso y la simulaci\u00f3n.</p> <p> <p> Primer proyecto</p> <p></p> <p>Podemos observar que tras unos instantes el programa comienza a ejecutarse en la micro:bit conectada. En el caso de Microblocks el bloque usado solamente permite un car\u00e1cter y no crea la animaci\u00f3n si ponemos mas de uno. Para hacer esto tenemos disponible otro bloque.</p> <p>Ya tenemos creado el programa y comprobado que funciona, es hora de salvarlo en el ordenador. Esto lo haremos asi principalmente para tener disponibles todos los programas y poder enlazarlos donde convenga en estas notas. En la animaci\u00f3n siguiente vemos el proceso de descarga del archivo.</p> <p> <p> Descarga del archivo Primer-proyecto.ubp</p> <p></p> <p>El Primer proyecto lo podemos descargar desde este enlace.</p> <p>Durante el proceso de cambios en el programa podemos comprobar que el conjunto de bloques esta rodeado de una l\u00ednea verde que indica que el programa se est\u00e1 ejecutando en la micro:bit. Lo apropiado cuando vamos a realizar cambios es detener la ejecuci\u00f3n, hacer los cambios y volver a poner la ejecuci\u00f3n en marcha.</p> <p> <p> Realizando cambios</p> <p></p> <p>En la animaci\u00f3n vemos junto a los botones de inicio/parada el icono indicador de progreso de la sincronizaci\u00f3n entre el IDE y la placa.</p>"},{"location":"Miscelanea/about/","title":"Autor","text":"<p>Federico Coca</p> <ul> <li> <p>GitHub</p> </li> <li> <p>Twitter</p> </li> <li> <p>Instagram</p> </li> <li> <p>Mas informaci\u00f3n</p> </li> </ul>"},{"location":"Miscelanea/lic/","title":"Licencias","text":"<ul> <li> <p>Licencia MIT incluida en la creaci\u00f3n del repositorio.</p> </li> <li> <p>Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 </p> </li> </ul> <p> <p> </p> <p></p>"},{"location":"Miscelanea/soft/","title":"Software utilizado","text":"<ul> <li> <p>Sistema operativo: Ubuntu 22.04</p> </li> <li> <p>Paquete ofim\u00e1tico de referencia: LibreOffice</p> </li> <li> <p>Libreria Material para MkDocs</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>Creaci\u00f3n de GIF animados para Ubuntu Peek</p> </li> <li> <p>Sistema principal de capturas de pantalla: Shutter</p> </li> <li> <p>Dibujo 2D vectorial Inkscape</p> </li> <li> <p>Retoque de im\u00e1genes GIMP</p> </li> <li> <p>Editor de MicroBlocks</p> </li> </ul>"},{"location":"Miscelanea/webgrafia/","title":"Webgraf\u00eda y bibliograf\u00eda","text":"<ul> <li> <p>Wikipedia</p> </li> <li> <p>Web de MicroBlocks</p> </li> <li>Editor online de MicroBlocks</li> <li>Wiki de MicroBlocks</li> <li>Web Ardutaller de Francisco Soldado.</li> <li>Web Mis notas sobre ESP32 STEAMakers</li> <li>Web Retos demo ESP32 Steamakers + TDR-Steam + Arduinoblocks (IoT) de Pedro Ru\u00edz.</li> </ul>"},{"location":"actividades/A1/","title":"A1- Diodos LED","text":"<p>Actividades resueltas y propuestas con los dos diodos LED que incorpora la placa TdR STEAM.</p>"},{"location":"actividades/A1/#led-rojo","title":"LED rojo","text":"<p>La placa Imagina TDR STEAM dispone de un LED rojo conectado al pin D12 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> LED rojo en la TdR STEAM</p> <p></p> <p>En el video siguiente vemos el funcionamiento \"en vivo\" del programa en la placa y en el ordenador, una de las grandes ventajas de MicroBlocks, mediante un sencillo programa que nos permite encender y apagar el LED de forma manual.</p> <p> <p></p> <p>Podemos descargar el programa LED_rojo.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> LED_rojo.ubp</p> <p></p>"},{"location":"actividades/A1/#led-azul","title":"LED azul","text":"<p>La placa Imagina TDR STEAM dispone de un LED azul conectado al pin D13 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> LED azul en la TdR STEAM</p> <p></p> <p>Debemos tener presente que el LED conectado al pin 13 va a parpadear siempre que reiniciemos la placa, lo cual ocurre cada vez que carguemos firmware en la misma. Una vez finalizada la carga el LED se comportar\u00e1 seg\u00fan indiquemos en nuestro programa.</p> <p>En el video siguiente vemos el funcionamiento de un sencillo programa que hace que el LED parpadee a intervalos de un segundo.</p> <p> <p></p> <p>Podemos descargar el programa LED_azul.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> LED_azul.ubp</p> <p></p>"},{"location":"actividades/A1/#multitarea","title":"Multitarea","text":"<p>Vamos a comprobar como MicroBlocks es por naturaleza capaz de trabajar en multitarea. Para ello vamos a hacer parpadear a ambos diodos LED a diferentes intervalos de tiempo y como se produce el efecto sin ning\u00fan tipo de problema. Adem\u00e1s en este caso la placa base es una ESP32 que ya dispone de doble n\u00facleo de procesador, por lo que la multitarea de dos tareas nos es ning\u00fan problema.</p> <p>En el video siguiente vemos el funcionamiento de un programa que hace que el LED rojo parpadee a intervalos de 500 ms y el diodo LED azul a intervalos de 1.3 ms.</p> <p> <p></p> <p>Podemos descargar el programa Multitarea_D12_D13.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> Multitarea_D12_D13.ubp</p> <p></p>"},{"location":"actividades/A1/#ampliacion","title":"Ampliaci\u00f3n","text":"<p>Se proponen, como retos de ampliaci\u00f3n, las siguientes actividades:</p> <p>R1_A1. Cambiar los tiempos para que el parpadeo sea m\u00e1s r\u00e1pido, mas lento y que los tiempos de encendido y apagado no coincidan utilizando uno solo de los diodos LED.</p> <p>R2_A1. Crear un programa que haga que los LEDs rojo y azul se enciendan simult\u00e1neamente con tiempos de espera de 300ms y 150ms respectivamente.</p> <p>R3_A1. Crear un programa que realice 4 intermitencias de 500ms con el LED azul y cuando estas acaben que encienda el LED rojo durante 1.5 segundos. Crear una espera un segundo antes de iniciar de nuevo el proceso.</p> <p>Soluci\u00f3n R3_A1 <p> <p> Soluci\u00f3n R3_A1</p> <p></p> <p>R4_A1. Crear un programa que realice 5 intermitencias de 500ms con el LED azul cada vez que el LED rojo lo hace 3 veces a intervalos de 150ms. Esperar un segundo para iniciar de nuevo el proceso.</p> <p>R5_A1. Cambiar los tiempos en el ejemplo de multitarea de forma que coincidan y tambi\u00e9n que sean uno m\u00faltiplo del otro, analizando los resultados.</p>"},{"location":"actividades/A2/","title":"A2- Diodo LED RGB","text":""},{"location":"actividades/A2/#actividad","title":"Actividad","text":"<p>La placa Imagina TDR STEAM dispone de un LED RGB conectado a los pines D6, D9 y D10 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> LED RGB en la TdR STEAM</p> <p></p> <p>El programa de la actividad va a consistir en encender de manera secuencial cada uno de los diodos R, G y B de manera individual. En el video siguiente vemos el funcionamiento del programa despu\u00e9s de poner en funcionamiento el bloque \"TdR set RGB LED.</p> <p> <p></p> <p>Podemos descargar el programa LED_RGB.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> LED_RGB.ubp</p> <p></p>"},{"location":"actividades/A2/#ampliacion","title":"Ampliaci\u00f3n","text":"<p>Se proponen, como retos de ampliaci\u00f3n, las siguientes actividades:</p> <p>R1_A2. A partir de la idea del reto realizar un programa que muestre sucesivamente los siguientes colores: magenta o violeta, cian o azul claro, amarillo y blanco. Nos podemos ayudar del gr\u00e1fico que muestra el modelo aditivo de colores que encontramos en la Wikipedia.</p> <p>R2_A2. Crear un programa que muestre un color aleatorio cada dos segundos.</p> <p>Soluci\u00f3n R2_A2 <p> <p> Soluci\u00f3n R2_A2</p> <p></p> <p>R3_A2. Crear un programa que muestre de manera secuencial los colores del arcoiris en el orden que vemos en la imagen.</p> <p> <p> Colores del arcoiris</p> <p></p>"},{"location":"actividades/A3/","title":"A3- Zumbador","text":""},{"location":"actividades/A3/#actividad","title":"Actividad","text":"<p>La placa Imagina TDR STEAM dispone de un zumbador pasivo o altavoz (Buzzer) conectado al pin D8 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> El zumbador pasivo o altavoz (Buzzer)</p> <p></p> <p>El programa de la actividad va a consistir en crear los bloques de las notas musicales b\u00e1sicas y reproducir algunas de ellas. En el video siguiente vemos y escuchamos el funcionamiento del programa.</p> <p> <p></p> <p>Podemos descargar el programa Buzzer.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> Buzzer.ubp</p> <p></p>"},{"location":"actividades/A3/#ampliacion","title":"Ampliaci\u00f3n","text":"<p>Se proponen, como retos de ampliaci\u00f3n, las siguientes actividades:</p> <p>R1_A3. A partir del bloque crear un programa que reproduzca las escala musical b\u00e1sica.</p> <p>Soluci\u00f3n R1_A3 <p> <p> Soluci\u00f3n R1_A3</p> <p></p> <p>R2_A3. Completar la escala musical del reto anterior con las notas que faltan.</p> <p>R3_A3. Crear un programa que reproduzca la melod\u00eda de la imagen siguiente sabiendo que las negras tienen una duraci\u00f3n de 500ms, las negras con un puntito 750ms y las blancas 1000ms.</p> <p> <p> Himno a la alegria</p> <p></p>"},{"location":"actividades/A4/","title":"A4- Pulsadores","text":""},{"location":"actividades/A4/#actividad","title":"Actividad","text":"<p>La placa TdR STEAM dispone de dos pulsadores denominados SW1 y SW2 y conectados a los pines digitales D2 y D7 respectivamente, tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> Pulsadores en la TdR STEAM</p> <p></p> <p>El programa de la actividad va a consistir en hacer un programa en el que preguntemos si el pulsador SW1 (D2) est\u00e1 o no pulsado y si lo est\u00e1 que se encienda el LED rojo (D12) y si no lo pulsamos que permanezca apagado. En el video siguiente vemos el funcionamiento del programa.</p> <p> <p></p> <p>Podemos descargar el programa pulsador.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> Pulsador.ubp</p> <p></p>"},{"location":"actividades/A4/#complementaria","title":"Complementaria","text":"<p>En esta ocasi\u00f3n vamos a crear una actividad complementaria que utiliza ambos pulsadores.</p> <p>El programa de la actividad va a consistir en hacer que se encienda el LED azul al pulsar SW1 y el LED rojo al pulsar SW2 se encienda el rojo permaneciendo apagados si no est\u00e1n pulsados. Observese la primera condici\u00f3n AND (Y) que impide que si pulsamos ambos pulsadores al mismo tiempo se enciendan los LEDs. En el video siguiente vemos el funcionamiento del programa.</p> <p> <p></p> <p>Podemos descargar el programa pulsadores.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> Pulsadores.ubp</p> <p></p>"},{"location":"actividades/A4/#ampliacion","title":"Ampliaci\u00f3n","text":"<p>Se proponen, como retos de ampliaci\u00f3n, las siguientes actividades:</p> <p>R1_A4. Resolver la actividad inicial de forma que el funcionamiento sea al contrario, es decir, que el LED rojo est\u00e9 siempre encendido y al pulsar SW1 se apague.</p> <p>R2_A4. Hacer un programa que al pulsar SW1 se encienda el LED azul y que al pulsar SW2 se apague. Como ampliaci\u00f3n se sugiere modificar el programa para que encienda y apague los dos LEDs a un tiempo.</p> <p>R3_A4. Hacer un programa que emita, usando SW1 como si fuese un tel\u00e9grafo, el c\u00f3digo Morse universal de solicitud de socorro, SOS. El alfabeto Morse lo vemos en la imagen siguiente:</p> <p> <p> Alfabeto Morse</p> <p></p> <p>Soluci\u00f3n R3_A4 <p>Podemos observar que la S son tres puntos o pulsaciones cortas y la O son tres rayas o pulsaciones largas. Sin entrar en mas detalles daremos la soluci\u00f3n considerando SOS como una palabra (es lo universalmente adoptado) de forma que no haremos pausas entre letras.</p> <p> <p> Soluci\u00f3n R3_A4</p> <p></p> <p>R4_A4. Hacer un programa que al pulsar SW1 encienda el LED azul y que este permanezca encendido hasta que no pulsemos SW1 dos veces mas (3 pulsaciones en total), en cuyo caso se apagar\u00e1.</p> <p> <p> Soluci\u00f3n R4_A4</p> <p></p>"},{"location":"actividades/A5/","title":"A5- El potenci\u00f3metro","text":""},{"location":"actividades/A5/#actividad","title":"Actividad","text":"<p>La placa Imagina TDR STEAM dispone de un potenci\u00f3metro, denominado Rotation, conectado al pin A0 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> El potenciometro de la TdR STEAM</p> <p></p>"},{"location":"actividades/A5/#parte-1","title":"Parte 1","text":"<p>El programa de esta parte de la actividad va a consistir en graficar los datos suministrados por el potenci\u00f3metro. En el video siguiente vemos el funcionamiento del programa.</p> <p> <p></p> <p>Podemos descargar el programa potenciometro_parte1.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> potenciometro_parte1.ubp</p> <p></p> <p>\u00a1MUY IMPORTANTE! Si la placa no se conecta <ul> <li>Cuando terminemos de manipular el potenci\u00f3metro para el objetivo del programa actual, debemos asegurarnos de que el mismo est\u00e9 totalmente girado a la posici\u00f3n izquierda. Si no est\u00e1 en esa posici\u00f3n se producir\u00e1 un error en el siguiente intento de env\u00edo del programa.</li> </ul>"},{"location":"actividades/A5/#parte-2","title":"Parte 2","text":"<p>El programa de esta parte de la actividad va a consistir en graficar los datos suministrados por el potenci\u00f3metro pero mapeando los valores. En el video siguiente vemos el funcionamiento del programa.</p> <p> <p></p> <p>Podemos descargar el programa potenciometro_parte2.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> potenciometro_parte2.ubp</p> <p></p>"},{"location":"actividades/A5/#ampliacion","title":"Ampliaci\u00f3n","text":"<p>Se proponen, como retos de ampliaci\u00f3n, las siguientes actividades:</p> <p>R1_A5. A partir del programa de la actividad (parte 1 o parte 2) crear un programa que nos muestre el mensaje \"Potenciometro: \" y a continuaci\u00f3n nos muestre el valor leido. Dejaremos transcurrir un tiempo de 3s entre cada actualizaci\u00f3n del dato de salida.</p> <p>R2_A5. Control del LED RGB con el potenciometro. Vamos a dividir el rango total en 8 partes y asignarle a cada una de ellas uno de los colores RGB seg\u00fan vemos en la tabla siguiente:</p> <p> Color Rango R G B Rojo 0 a 127 255 0 0 Verde 128 a 255 0 255 0 Azul 256 a 384 0 0 255 Amarillo 385 a 512 255 255 0 Cian 513 a 640 0 255 255 Magenta 641 a 768 255 0 255 Blanco 769 a 896 255 255 255 Naranja 897 a 1023 255 127 0 <p></p> <p>R3_A5. Repetir R2_A5 pero ahora adem\u00e1s mostrando por de forma gr\u00e1fica el valor del potenciometro.</p>"},{"location":"actividades/A6/","title":"A6- La fotorresistencia o LDR","text":""},{"location":"actividades/A6/#actividad","title":"Actividad","text":"<p>La placa Imagina TDR STEAM dispone de una resistencia LDR, denominada Light, conectada al pin A1 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> La LDR en la TdR STEAM</p> <p></p> <p>El programa de la actividad va a consistir en mostrar los datos suministrados por la LDR. En el video siguiente vemos el funcionamiento del programa.</p> <p> <p></p> <p>Podemos descargar el programa LDR.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> LDR.ubp</p> <p></p>"},{"location":"actividades/A6/#ampliacion","title":"Ampliaci\u00f3n","text":"<p>Se proponen, como retos de ampliaci\u00f3n, las siguientes actividades:</p> <p>R1_A6. Detectar el nivel de iluminaci\u00f3n de la sala y condiciones de iluminaci\u00f3n en las que estemos utilizando la LDR y graficar el resultado.</p> <p>R2_A6. Programar un interruptor crepuscular utilizando la LDR y uno de los LEDs para simular el farol. El nivel de luz m\u00ednimo permitido antes de encender el farol depender\u00e1 del resultado obtenido en la R1_A6, de forma que con un valor menor o igual se encienda el LED y con un valor mayor permanezca apagado.</p> <p>R3_A6. Programar el interruptor crepuscular utilizando como farol el LED RGB que se encender\u00e1 en color blanco.</p>"},{"location":"actividades/A7/","title":"A7- El sensor de temperatura LM35D","text":""},{"location":"actividades/A7/#actividad","title":"Actividad","text":"<p>La placa Imagina TDR STEAM dispone de un sensor de temperatura LM35D, denominada LM35, conectada al pin A2 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> El LM35 en la TdR STEAM</p> <p></p> <p>El programa de la actividad va a consistir en mostrar los datos de temperatura suministrados por el LM35D. En el video siguiente vemos el funcionamiento del programa.</p> <p> <p></p> <p>Podemos descargar el programa Temperatura_LM35D.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> Temperatura_LM35D.ubp</p> <p></p>"},{"location":"actividades/A7/#ampliacion","title":"Ampliaci\u00f3n","text":"<p>Se proponen, como retos de ampliaci\u00f3n, las siguientes actividades:</p> <p>R1_A7. Repetir el programa de la actividad mostrando los datos de forma gr\u00e1fica durante unas cuantas horas o incluso un d\u00eda completo. Registramos un dato cada 30 minutos. Al final del tiempo archivamos los datos en formato CSV y los analizamos de manera anal\u00edtica y gr\u00e1fica.</p> <p>R2_A7. Alarma \u00f3ptico/ac\u00fastica por sobrepasar una temperatura de, por ejemplo, 25\u00baC. Utilizaremos el zumbador para emitir alg\u00fan pitido y los LEDs rojo y azul encendi\u00e9ndose y apag\u00e1ndose alternativamente para la indicaci\u00f3n \u00f3ptica.</p> <p>R3_A7. Sem\u00e1foro indicador de rangos de temperatura. Se trata de programar un sem\u00e1foro con el LED RGB que se iluminar\u00e1 en color verde si la temperatura est\u00e1 por debajo de 25\u00baC, en rojo si est\u00e1 por encima de 35\u00baC y en amarillo si est\u00e1 entre ambos valores.</p>"},{"location":"actividades/A8/","title":"A8- El sensor de temperatura y humedad DHT-11","text":""},{"location":"actividades/A8/#actividad","title":"Actividad","text":"<p>La placa Imagina TDR STEAM incorpora un sensor DHT11, denominada DHT11, conectada al pin D4 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> El DHT11 en la TdR STEAM</p> <p></p> <p>El programa de la actividad va a consistir en mostrar los datos de temperatura y humedad suministrados por el DHT11. En el video siguiente vemos el funcionamiento del programa.</p> <p> <p></p> <p>Podemos descargar el programa Temp_Hum_DHT11.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> Temp_Hum_DHT11.ubp</p> <p></p>"},{"location":"actividades/A8/#ampliacion","title":"Ampliaci\u00f3n","text":"<p>Se proponen, como retos de ampliaci\u00f3n, las siguientes actividades:</p> <p>R1_A8. Repetir el programa de la actividad mostrando los datos de forma gr\u00e1fica durante unas cuantas horas o incluso un d\u00eda completo. Registramos un dato de temperatura y humedad cada 30 minutos. Al final del tiempo archivamos los datos en formato CSV y los analizamos de manera anal\u00edtica y gr\u00e1fica.</p> <p>R2_A8. Realizar un programa que nos muestre el estado de confort seg\u00fan las explicaciones vista en la actividad 10 de Notas sobre ESP32 STEAMakers y la idea de un sem\u00e1foro que utilice el LED RGB para componer esos colores rojo, verde y amarillo.</p> <p>Para resolver la actividad vamos a necesitar varios bloques del men\u00fa \"Operadores\" y especialmente combinando funciones AND y OR m\u00faltiples.</p>"},{"location":"actividades/A9/","title":"A9- Emisor y receptor de infrarrojos","text":""},{"location":"actividades/A9/#actividad","title":"Actividad","text":"<p>La placa Imagina TDR STEAM incorpora un diodo receptor de infrarrojos, denominada IR Receiver, conectada al pin D11 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente:</p> <p> <p> El sensor receptor de IR en la TdR STEAM</p> <p></p> <p>En nuestro caso como emisor de infrarrojos vamos a utilizar el control remoto de Keyestudio que vemos en la imagen siguiente:</p> <p> <p> Control remoto de Keyestudio</p> <p></p> <p>La actividad va a consistir en crear un programa que nos permita averiguar el c\u00f3digo num\u00e9rico que se recibe cuando se pulsa cada una de las teclas.</p> <p>En el video siguiente vemos el funcionamiento del programa.</p> <p> <p></p> <p>El resultado para cada tecla lo vemos en la figura siguiente:</p> <p> <p> C\u00f3digos del teclado de Keyestudio en MicroBlocks</p> <p></p> <p>Podemos descargar el programa Recep_Emisor_IR.ubp o bien crearlo nosotros mismos a partir de la figura siguiente:</p> <p> <p> Recep_Emisor_IR.ubp</p> <p></p>"},{"location":"actividades/A9/#ampliacion","title":"Ampliaci\u00f3n","text":"<p>Se proponen, como retos de ampliaci\u00f3n, las siguientes actividades:</p> <p>R1_A9. Reformar el programa de la actividad de manera que nos informe de la tecla pulsada pero no con el c\u00f3digo, sino con la descripci\u00f3n de la tecla.</p> <p>R2_A9. Realizar un programa en el que si pulsamos la tecla Ok del control remoto se nos encienda el diodo LED rojo y si pulsamos cualquier otra se apague.</p> <p>R3_A9. Realizar un programa que encienda el LED RGB en los colores establecidos a continuaci\u00f3n y seg\u00fan la tecla flecha pulsada.</p> <ul> <li>Flecha arriba = Rojo</li> <li>Flecha izquierda = Verde</li> <li>Flecha derecha = Amarillo</li> <li>Flecha abajo = azul</li> </ul>"},{"location":"info/hard_esp/","title":"Hardware de la ESP32 STEAMakers","text":""},{"location":"info/hard_esp/#generalidades-sobre-esp32","title":"Generalidades sobre ESP32","text":"<p>En este apartado vamos a realizar algunas consideraciones sobre los siguientes aspectos de las placas ESP32:</p> <ul> <li>Pines</li> <li>Entradas anal\u00f3gicas</li> <li>Entradas y salidas digitales</li> <li>Salidas PWM en ESP32</li> </ul>"},{"location":"info/hard_esp/#pines-en-esp32","title":"Pines en ESP32","text":"<p>En general los pines en ESP32 son de tipo GPIO (General Purpose Input/Output, Entrada/Salida de Prop\u00f3sito General). Algunos pines GPIO pueden tener un comportamiento no esperado durante el arranque del sistema o en el reinicio del mismo. Esto se debe a que durante el arranque de la placa ESP32 se deben realizar procesos internos que ponen en alto ciertos pines o incluso hacen que emitan se\u00f1ales, y esto puede provocar esos efectos no deseados.</p> <p>El pin GPIO1 del microcontrolador es el pin Tx del puerto UART de depuraci\u00f3n y cuando la placa arranca, se reinicia o cuando nosotros hacemos uso del puerto serie, este pin emite datos. Por este motivo es un pin que no conviene usar como entrada o salida.</p> <p>El GPIO3 tiene un problema similar al GPIO1 ya que se trata del pin Rx del micocontrolador.</p> <p>Los pines GPIO34, GPIO35, GPIO36 y GPIO39 solamente pueden utilizarse como entradas porque no disponen de resistencia pull-up.</p>"},{"location":"info/hard_esp/#entradas-analogicas","title":"Entradas anal\u00f3gicas","text":"<p>Las se\u00f1ales anal\u00f3gicas son las que pueden tomar diferentes valores de tensi\u00f3n en un determinado periodo de tiempo, siendo su forma mas caracter\u00edstica la senoidal. Cuando hablamos de entradas anal\u00f3gicas estamos hablando de pines del microcontrolador que pueden leer esas se\u00f1ales. En el caso de ESP32 todo son pines GPIO y por lo tanto se requiere de un conversor anal\u00f3gico a digital que sea capaz de transformar esas se\u00f1ales anal\u00f3gicas en digitales. El chip ESP32 que monta la placa ESP32 STEAMakers dispone de 2 convertidores Digital-Anal\u00f3gico (DAC) de 8 bits y 16 convertidores Anal\u00f3gico-Digital (ADC) de 12 bits. Estos conversores se asocian a los pines IO1 hasta IO20.</p> <p>La resoluci\u00f3n de los conversores ADC es de 12 bits (2^12 = 4096) por lo que la transformaci\u00f3n de los valores digitales va a ser de mucha precisi\u00f3n. Pero cuidado con el uso de estas entradas, porque en realidad su comportamiento es que est\u00e1n leyendo valores digitales y no valores anal\u00f3gicos por lo que cambios de valores anal\u00f3gicos muy peque\u00f1os pueden no ser detectados.</p> <p>Los canales ADC se dividen en dos puertos denominados ADC1 y ADC2. Las entradas anal\u00f3gicas del puerto ADC2 solamente las podemos usar como tales si el controlador WiFi no ha sido iniciado, ya que este puerto es el que utiliza el controlador del WiFi que integra la placa.</p>"},{"location":"info/hard_esp/#entradas-y-salidas-digitales","title":"Entradas y salidas digitales","text":"<p>Una se\u00f1al digital solamente puede tomar dos valores o estados l\u00f3gicos, alto y bajo, High y Low, 0 y 1 siendo su representaci\u00f3n caracter\u00edstica una onda cuadrada. El estado bajo se asocia a cero voltios y el estado alto a 3.3V (5V en el caso de placa tipo UNO).</p> <p>Las entradas permiten recibir se\u00f1ales con los valores digitales descritos, como por ejemplo leer el estado de un pulsador.</p> <p>Debemos saber que ESP32 lleva unas resistencias de pull-up (1) o pull-down (0) que nos permiten establecer el estado que tiene la entrada cuando est\u00e1 en reposo. Estas resistencias est\u00e1n disponibles en todos los pines excepto el 34 y 39. Estas resistencias internas se pueden activar por c\u00f3digo.</p> <p>Las salidas digitales nos van a servir para realizar acciones sobre los elementos conectadas en ellas, como por ejemplo encender un LED o activar un rel\u00e9.</p> <p>En principio todos los pines que se pueden utilizar como salida en ESP32 pueden usarse con PWM excepto los pines que no disponen de resistencia de pull-up interna.</p>"},{"location":"info/hard_esp/#esp32-plus-steamakers","title":"ESP32 Plus STEAMakers","text":"<p>La placa ESP32 Plus STEAMakers nos ofrece una gran cantidad de prestaciones al estar basada en un microcontrolador de 32 bits con conectividad WiFi y Bluetooth integradas en la propia placa y tambi\u00e9n un z\u00f3calo para tarjetas \u00b5SD para el almacenamiento de datos. Tambi\u00e9n dispone de conexiones para todas las entradas y salidas con posibilidad de tener la alimentaci\u00f3n adjunta y puertos de expansi\u00f3n I2C para poder conectar diferentes dispositivos directamente en la placa. En la figura siguiente vemos su aspecto.</p> <p> <p> Aspecto de la placa ESP32 Plus STEAMakers</p> <p></p> <p>La placa est\u00e1 basada en el microcontrolador ESP32-WROOM-32 y sus principales especificaciones t\u00e9cnicas son:</p> <ul> <li>Microcontrolador Tensilica Xtensa 32-bit LX6 a 160MHz.</li> <li>Conectividad WiFi 802.11 b/g/n/e/i.</li> <li>Conectividad Bluetooth 4.2 y modo BLE.</li> <li>Z\u00f3calo para tarjetas \u00b5SD.</li> <li>14 entradas y salidas digitales con alimentaci\u00f3n.</li> <li>Conector serie hembra con alimentaci\u00f3n.</li> <li>Conector I2C para conectar hasta 5 dispositivos a la vez sobre la misma placa.</li> <li>Conector hembra I2C para conexi\u00f3n de una pantalla OLED.</li> <li>Bot\u00f3n de Reset.</li> <li>Conector de 5V</li> <li>Conector de 3.3V</li> <li>Interruptor 3.3-5V para cambiar entre estas dos tensiones en algunos pines de alimentaci\u00f3n.</li> <li>Entradas y salidas anal\u00f3gicas.</li> <li>Sensor Hall y de temperatura integrado.</li> <li>2 convertidores Digital-Anal\u00f3gico (DAC) de 8 bits.</li> <li>16 convertidores Anal\u00f3gico-Digital (ADC) de 12 bits.</li> <li>16 canales PWM.</li> <li>2 UART.</li> <li>2 canales I2C.</li> <li>4 canales SPI.</li> <li>448Kb ROM.</li> <li>520 KB SRAM.</li> <li>8KB+8KB SRAM en RTC.</li> <li>1kbit eFUSE.</li> <li>512 bytes Memoria Flash (EEPROM).</li> <li>10 sensores t\u00e1ctiles.</li> <li>4 temporizadores internos de 64 bits.</li> </ul> <p>En la ESP32 ST$EAMakers no est\u00e1n disponibles todas las caracter\u00edsticas del controlador ESP-WROOM-32, ya que algunos pines tienen funciones dobles y se utilizan en la placa de forma espec\u00edfica (como, por ejemplo, para controlar la tarjeta SD). Pero la mayor\u00eda de funciones se pueden utilizar, adem\u00e1s de disponer la placa ESP32 Plus STEAMakers de una mejor conexi\u00f3n de elementos debido a los pines para conectores tipo Dupont de entrada y salida, de I2C y de alimentaci\u00f3n. Adem\u00e1s, algunos pines de alimentaci\u00f3n pueden cambiar su valor (3,3V o 5V) mediante un interruptor en funci\u00f3n de nuestras necesidades.</p> <p>En la figura siguiente vemos un momento del video descriptivo de la placa ESP32 STEAMakers que se aloja en el canal Youtube de ArduinoBlocks.</p> <p> <p> Comparativa de la ESP32 STEAMakers con otras placas populares</p> <p></p> <p>En la figura siguiente vemos los elementos que componen la placa ESP32 Plus STEAMakers:</p> <p> <p> Elementos en la placa ESP32 Plus STEAMakers</p> <p></p>"},{"location":"info/hard_esp/#relacion-conexiones-tipo-uno","title":"Relaci\u00f3n conexiones tipo UNO","text":"<p>Las conexiones de la placa Imagina TDR STEAM con la placa ESP32 Plus STEAMakers son las mismas que si utilizamos cualquier placa compatible con Arduino UNO. En la tabla siguiente se establece la relaci\u00f3n entre los elementos de la placa Imagina TdR STEAM y las conexiones de una placa ESP32 Plus STEAMakers.</p> <p> Pin UNO Uso en TdR STEAM Descripci\u00f3n D0 Rx Pin de recepci\u00f3n Bluetooth y WiFi D1 Tx Pin de transmisi\u00f3n Bluetooth y WiFi D2 Pulsador SW1 Entrada digital D3 Conector para entrada/salida digital externa Entrada/salida digital D4 Sensor de Temperatura y Humedad DHT11 Entrada digital D5 Conector para entrada/salida digital externa Entrada/salida digital D6 Color rojo del LED RGB Salida digital D7 Pulsador SW2 Entrada digital D8 Zumbador o buzzer Salida digital D9 Color verde del LED RGB Salida digital D10 Color azul del LED RGB Salida digital D11 Sensor IR Entrada digital D12 LED rojo Salida digital D13 LED azul Salida digital A0 Potenci\u00f3metro Entrada anal\u00f3gica A1 Sensor de luz (LDR) Entrada anal\u00f3gica A2 Sensor de temperatura (LM35) Entrada anal\u00f3gica A3 Conector para entrada anal\u00f3gica externa Entrada anal\u00f3gica A4 SDA (Serial DAta.) Datos I2C A5 SCL (Serial CLock) Se\u00f1al de reloj I2C <p></p>"},{"location":"info/hard_esp/#compatibilidad-y-descripcion-de-pines-esp32-steamakers","title":"Compatibilidad y descripci\u00f3n de pines ESP32 STEAMakers","text":"<p>Importante: Todos los pines IOxx son entradas y salidas digitales, algunas con m\u00e1s funciones. Utilizando la comunicaci\u00f3n WiFi no funciona el ADC2.</p> <p>En la tabla siguiente tenemos relacionados todos los pines entre los tipos de placas UNO, Imagina TdR STEAM y ESP32 STEAMakers.</p> <p> UNO TdR STEAM ESP32 Pin Funci\u00f3n Pin Funci\u00f3n Ampliaci\u00f3n D0 Rx IO03 Rx UART 0 RX D1 Tx IO01 Tx UART 0 TX D2 Pulsador SW1 IO26 ADC2 CH9 DAC2 D3 Libre IO25 ADC2 CH8 DAC1 D4 DHT11 IO17 UART 2 TX D5 Libre IO16 UART 2 RX D6 Color rojo del LED RGB IO27 ADC2 CH7 ADC2-7 / TOUCH7 D7 Pulsador SW2 IO14 ADC2 CH6 ADC2-6 / TOUCH6 D8 Zumbador o buzzer IO12 ADC2 CH5 ADC2-5 / TOUCH5 D9 Color verde del LED RGB IO13 ADC2 CH4 ADC2-4 / TOUCH4 D10 Color azul del LED RGB IO05 VSPI CSO D11 Sensor IR IO23 VSPI MOSI D12 LED rojo IO19 VSPI MISO D13 LED azul IO18 VSPI CLK GND GND AREF Reset SDA I2C IO21 SCL I2C IO22 A0 Potenci\u00f3metro IO02 ADC2 CH2 A1 Sensor de luz (LDR) IO04 ADC2 CH0 A2 Sensor de temperatura (LM35) IO36 ADC1 CH0 A3 Libre IO34 ADC1 CH6 A4 I2C IO38 A5 I2C IO39 ADC1 CH3 VIN VIN GND GND GND GND 5V 5V 3.3V 3.3V RST Reset 5V 5V IO00 \u00a1 No conectar ! - IO32 D0 - uSD - IO15 CLK - uSD - IO33 CMD - uSD - IO35 IOUT Medidor de corriente - IO37 VOUT Medidor de tensi\u00f3n <p></p>"},{"location":"info/hard_tdr/","title":"Hardware de la TdR STEAM","text":"<p>En la figura siguiente se enumeran los sensores y actuadores de la TdR STEAM.</p> <p> <p> Sensores y actuadores en la TdR STEAM</p> <p></p> <p>En la tabla se detallan los elementos y se detallan los pines a los que est\u00e1n conectados. Los pines se indican en formato UNO y no ESP32 que se har\u00e1 en el apartado Hardware ESP32 STEAMakers.</p> <p> N Sensor, actuador o dispositivo externo Pin de conexi\u00f3n 1 Interface I2C o IIC SDA-A4 y SCL-A5 2 Pulsadores SW1 y SW2 D2 y D7 3 Diodos LED Azul (LED3) y Rojo (LED4) D13 y D12 4 Led RGB o neopixel D6, D9 y D10 5 Dos conectores para Entradas/Salidas digitales D3 y D5 6 Conector de comunicaciones Bluetooth y WiFi (Swich On/Off) Rx y Tx 7 Sensor de Temperatura y Humedad DHT11 D4 8 Potenci\u00f3metro giratorio de 270\u00ba A0 9 Zumbador Piezoel\u00e9ctrico o buzzer D8 10 Diodo receptor de infrarrojos (IR) D11 11 Sensor de luminosidad (LDR) A1 12 Bot\u00f3n de Reset Reset ESP32 13 Conector para entrada anal\u00f3gica A3 14 Sensor de temperatura (LM35) A2 <p></p>"},{"location":"info/importante/","title":"Importante","text":"<p>Para que MicroBlocks reconozca y se conecte con la placa, es muy importante que el potenci\u00f3metro est\u00e9 totalmente girado a la izquierda como est\u00e1 marcado en la imagen siguiente con el punto de color. Es decir la flecha del potenci\u00f3metro debe estar orientada a la posici\u00f3n del punto de color y no en la que est\u00e1 en la im\u00e1gen.</p> <p> <p> La posici\u00f3n del potenci\u00f3metro de la TdR STEAM</p> <p></p> <p>El motivo es que el potenci\u00f3metro comparte la conexi\u00f3n A0 (GPIO02) con el sistema de grabaci\u00f3n del programa y si el mismo no est\u00e1 en su posici\u00f3n de cero resistencia se producir\u00e1 un error en el env\u00edo del programa a la placa porque se entender\u00e1 que los pines de transmisi\u00f3n est\u00e1n ocupados con otra tarea.</p> <p>Una vez que tenemos el firmware de la placa actualizado esto ya no va a tener importancia, debido a que MicroBlocks trabaja en vivo (en tiempo real) actualizando el firmaware de la placa y mostra\u0144do los resultados de manera inmediata.</p>"}]}